<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
      <url>/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ol><li><h5 id="什么是结构型的设计模式"><a href="#什么是结构型的设计模式" class="headerlink" title="什么是结构型的设计模式"></a>什么是结构型的设计模式</h5><ul><li>类结构型：多个类组合成更大的类，只存在类继承和实现关系</li><li>对象结构型：类和对象组合的关联关系，根据合成复用原则，尽量使用关联关系代替继承</li></ul></li><li><h5 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h5><p>组装现有类成为一个更大的结构，扩展出更强大的功能</p></li></ol><h3 id="模式类型"><a href="#模式类型" class="headerlink" title="模式类型"></a>模式类型</h3><blockquote><p>注：按重要程度排序</p></blockquote><ol><li><h5 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h5><ul><li>说明：统一方法对象访问内部接口</li><li>结构<ul><li>Facade</li><li>SubInterface</li></ul></li><li>适用场景<ul><li>常用的MVC分层就是一种外观模式，比如service层聚合了dao</li><li>统一接入的API网关<a id="more"></a></li></ul></li></ul></li><li><h5 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h5><ul><li><p>说明：通过一个代理对象控制原对象</p><p>有一句名言可以让我们联想下</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决</p></blockquote></li><li><p>结构</p><ul><li><p>Proxy：代理类</p></li><li><p>Source：被代理类</p></li><li><p>SourceImpl：</p><blockquote><p>静态代理：代理和被代理对象都需要实现目标接口，在运行前就有Class文件了</p><p>动态代理：代理类和被代理类有一种关联关系，动态生成字节码加载到JVM中，编译完没有Class文件</p><ul><li>JDK动态代理：依靠反射机制获取接口实现</li><li>Cglib动态代理：对目标类生成子类以覆盖其子类方法</li></ul></blockquote><p>如下是一个静态代理的实现，但是扩展的时候需要一个类一个代理类，过多冗余所以又有了动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sourceable</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"real invoke"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Sourceable sourceable = <span class="keyword">new</span> Sourceable();</span><br><span class="line">        sourceable.invoke();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 增强功能</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jdk动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object SelfProxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用入口，</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jdkProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 原理：通过反射获取接口方法对象，所以必须依赖接口</span></span><br><span class="line">        Source source = (Source)Proxy.newProxyInstance(Source.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Source.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> JdkProxy(<span class="keyword">new</span> Sourceable()));</span><br><span class="line">        source.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>cglib动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cglibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原理：对目标类生成一个子类，覆盖其中方法，所以不能对final修饰的方法</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(ProxyTarget.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibProxy());</span><br><span class="line">        ProxyTarget proxyTarget = (ProxyTarget) enhancer.create();</span><br><span class="line">        proxyTarget.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>适用场景</p><ul><li>Aop：日志记录/性能统计/安全控制/事物处理/异常处理</li></ul></li></ul></li><li><h5 id="组合模式-（Composite）"><a href="#组合模式-（Composite）" class="headerlink" title="组合模式 （Composite）"></a>组合模式 （Composite）</h5><ul><li><p>说明：组合成部分和整体的分层结构</p></li><li><p>结构</p><ul><li><p>Tree</p></li><li><p>TreeNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tree tree = <span class="keyword">new</span> Tree(<span class="string">"A"</span>);</span><br><span class="line">        TreeNode childA = <span class="keyword">new</span> TreeNode(<span class="string">"B"</span>);</span><br><span class="line">        TreeNode childB = <span class="keyword">new</span> TreeNode(<span class="string">"C"</span>);</span><br><span class="line">        childB.getChildren().add(childA);</span><br><span class="line">        tree.setTreeNode(childB);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode treeNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        treeNode = <span class="keyword">new</span> TreeNode(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode treeNode;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; children = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>适用场景</p><ul><li>比如部门组织列表</li></ul></li></ul></li><li><h5 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h5><ul><li>说明</li><li>结构</li><li>适用场景</li></ul></li><li><h5 id="装饰器模式（Decorator）"><a href="#装饰器模式（Decorator）" class="headerlink" title="装饰器模式（Decorator）"></a>装饰器模式（Decorator）</h5><ul><li>说明</li><li>结构</li><li>适用场景</li></ul></li><li><h5 id="桥接模式-（Bridge）"><a href="#桥接模式-（Bridge）" class="headerlink" title="桥接模式 （Bridge）"></a>桥接模式 （Bridge）</h5><ul><li>说明</li><li>结构</li><li>适用场景</li></ul></li><li><h5 id="享元模式（蝇量，FlyWeight）"><a href="#享元模式（蝇量，FlyWeight）" class="headerlink" title="享元模式（蝇量，FlyWeight）"></a>享元模式（蝇量，FlyWeight）</h5><ul><li>说明</li><li>结构</li><li>适用场景</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型</title>
      <link href="/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>​    发现对于落地这件事情还是要静下心一个一个目标完成，设计模式一直搁浅了好久也没个系统整理，作为网上标配开篇，最近还是补上这个作业吧</p><ol><li><p>为什么用设计模式</p><ul><li>设计模式是前人总结下来的经验，对于扩展性和可维护性有很大帮助</li><li>也是为了使设计变得简单，容易阅读</li></ul></li><li><p>设计模式原则（SOLID）</p><ul><li>单一职责原则（<strong>S</strong>ingle Responsibility Principle）：可以理解为最好一个类只负责一项职责</li><li>开闭原则（<strong>O</strong>pen Close Priciple）：尽量对扩展开放，对修改关闭</li><li>里氏替换原则（<strong>L</strong>iskov Substitution Principle）：引用父类处可以用任意子类代替</li><li>接口隔离原则（<strong>I</strong>nterface Segregation priciple）：建立单一接口，最好是一个类依赖一个接口，而不是多个类依赖一个接口</li><li>依赖倒置原则 (<strong>D</strong>ependency InVersion Principle) ：调用方和实现方都应该依赖抽象，彼此相互独立，实现类应该依赖抽象，而不能反过来</li><li>迪米特法则（<strong>L</strong>aw of Demeter）：一个对象保持对其他对象最少的了解</li><li>合成复用原则（Composite/Aggregate Reuse Principle）：尽量使用组合/聚合，不要使用继承，继承基类会暴露实现破坏封装；基类改变，子类实现也需要改变；实现是静态的，不够灵活</li></ul></li><li><p>如何使用设计模式</p><p>以上原则只是设计参考的一个约束，并不绝对，对于“最好的设计模式就是不用设计模式”，我们还没有达到这个境界，只有合适的场景用更合适的方法。</p></li></ol><a id="more"></a><h3 id="设计模式-创建型"><a href="#设计模式-创建型" class="headerlink" title="设计模式-创建型"></a>设计模式-创建型</h3><p>目的：实例化过程的解耦</p><p>​    我们原先想获取一个新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>   之后在创建新对象的场景可以参考考虑一下使用以下的思路</p><ol><li><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><h6 id="说明：一个类只能有一个实例，提供全局唯一的访问点"><a href="#说明：一个类只能有一个实例，提供全局唯一的访问点" class="headerlink" title="说明：一个类只能有一个实例，提供全局唯一的访问点"></a>说明：一个类只能有一个实例，提供全局唯一的访问点</h6><ul><li><p>匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 私有构造器保证不能new 创建新实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInnerClass <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonInnerClass instance = <span class="keyword">new</span> SingletonInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum SingletonEnum &#123;</span><br><span class="line">    INSTACN；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双重检查锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDCL instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDCL <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDCL.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring单例注册表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. </span></span><br><span class="line"><span class="comment">提前曝光的单例Cache</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一级缓存 获取单例的bean</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 判断bean是否在创建中（并未创建完）</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 二级缓存 获取提前曝光的单例</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 判断是否允许提前引用</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">          <span class="comment">// 三级缓存 获取单例bean</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 放入二级缓存 并删除三级缓存中的bean</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面也直接说了spring 对于循环依赖的解决方案</p></li></ul></li><li><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>说明：根据传入的变量决定输出什么样的实例</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 产品实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"product A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"product B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"A"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"B"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><ol start="3"><li><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>说明：创建对象行为进行抽象，在子类里实现逻辑</p><p>适用场景：</p><ul><li><p>如下是spring中的工厂方法接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jdk中Collection类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 这是一个工厂方法</span></span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   实现在子类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="4"><li><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>说明：创建相关或依赖对象的家族，而无需明确指定具体类</p><pre><code>- Collection类中抽象了多个工厂方法，本身又是一个抽象的创建类</code></pre></li><li><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>说明：封装一个对象复杂的构建过程</p><ul><li><p>lombok  @Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Builder builder = Builder</span><br><span class="line">                   .age(<span class="number">10</span>)</span><br><span class="line">                    .name(<span class="string">"builder"</span>)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="6"><li><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>说明：实例对象的复制获取新实例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * 对象内的引用也被复制时为深拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Prototype prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        prototype.map = map;</span><br><span class="line">        prototype.name = name;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>以上是对创建型的设计模式的一些demo及一些源码的引用，目的是尽快的理解和快速的用起来，后续会补全UML图</p><p>其中最常用的是单例模式/工厂方法/抽象工厂/建造者模式，设计模式的主要目的也是为了代码的可维护性和可扩展性，把会变动的地方和不变的地方隔离开来</p></li></ol><p>如有不正确的地方欢迎大佬指正</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Relational And Non-Relational Storage System</title>
      <link href="/2019/05/05/Relational-And-Non-Relational-Storage-System/"/>
      <url>/2019/05/05/Relational-And-Non-Relational-Storage-System/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在研究ES的同时,有如下问题</p><ul><li>数据存储发展历史</li><li>关系型和非关系型对比</li><li>非关系型数据库是否支持事物</li></ul></blockquote><p>下面对以上问题进行展开</p><a id="more"></a><h2 id="数据存储发展历史"><a href="#数据存储发展历史" class="headerlink" title="数据存储发展历史"></a>数据存储发展历史</h2><p>TimeLine</p><blockquote><p>数据管理是数据库的核心任务,分类、组织、编码、储存、检索和维护</p><blockquote><ul><li>人工管理阶段<ul><li>没有对数据进行管理的软件系统</li><li>没有文件的概念</li><li>一组数据对应于一个程序，数据是面向应用的</li><li>数据不保存</li></ul></li><li>文件系统阶段<ul><li>数据需要长期保存在外存上供反复使用</li><li>程序之间有了一定的独立性</li><li>文件的形式已经多样化</li><li>数据的存取基本上以记录为单位</li></ul></li><li>数据库系统阶段<ul><li>采用复杂的结构化的数据模型</li><li>较高的数据独立性</li><li>最低的冗余度</li><li>数据控制功能</li></ul></li></ul></blockquote><p>数据模型是数据库系统的核心</p><blockquote><ol><li>第一代: 层次和网状数据库管理系统</li><li>第二代: 关系数据库管理系统(RDBMS)</li><li>第三代: <ul><li>面向对象的方法和技术，例如建立对象关系(OR)模型和建立对象关系数据库(ORDB)</li><li>数据库技术与多学科技术的有机结合: 例如分布式数据库、并行数据库、演绎数据库、知识库、多媒体库、移动数据库等</li><li>面向专门应用领域的数据库技术: 例如工程数据库、统计数据库、科学数据库、空间数据库、地理数据库、Web数据库</li></ul></li></ol></blockquote></blockquote><h2 id="关系和非关系型对比"><a href="#关系和非关系型对比" class="headerlink" title="关系和非关系型对比"></a>关系和非关系型对比</h2><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:left">Relational</th><th style="text-align:left">Non-Relational</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:left">采用了关系模型来组织数据的数据库</td><td style="text-align:left">非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:left">容易理解</td><td style="text-align:left">仅需要根据id取出相应的value就可以完成查询</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">使用方便</td><td style="text-align:left">适用于SNS(Social Networking Services),数据结构巨大变动</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">易于维护</td><td style="text-align:left">非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:left">硬盘I/O瓶颈</td><td style="text-align:left">只适合存储一些较为简单的数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">海量数据效率低下</td><td style="text-align:left">不适合持久存储海量数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">web的结构中难以横向扩展，需要停机和数据迁移</td><td style="text-align:left">不适合较复杂查询的数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">格式化的数据结构，多表关联查询性能欠佳</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">事务</td><td style="text-align:left">必须具备ACID特性</td><td style="text-align:left">不支持</td></tr><tr><td style="text-align:center">成本</td><td style="text-align:left">相比较高且复杂</td><td style="text-align:left">简单易部署，较低</td></tr><tr><td style="text-align:center">查询速度</td><td style="text-align:left">较慢</td><td style="text-align:left">数据存储于缓存之中，而且不需要经过SQL层的解析，较快</td></tr><tr><td style="text-align:center">存储数据的格式</td><td style="text-align:left">只支持基础类型</td><td style="text-align:left">key,value形式、文档形式、图片形式等等，基础类型以及对象或者是集合等各种格式</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:left">扩展很艰难</td><td style="text-align:left">数据之间没有耦合性，所以非常容易水平扩展</td></tr><tr><td style="text-align:center">持久存储</td><td style="text-align:left">海量数据的持久存储，还是需要关系型数据库</td><td style="text-align:left">不适用于持久存储</td></tr><tr><td style="text-align:center">数据一致性</td><td style="text-align:left">强一致性</td><td style="text-align:left">数据最终一致性，有可能有中间态的数据</td></tr><tr><td style="text-align:center">主流系统</td><td style="text-align:left">Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2,Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP</td><td style="text-align:left">面向高性能并发读写的key-value数据库：主流代表为Redis， Amazon DynamoDB， Memcached,Microsoft Azure Cosmos DB和Hazelcast</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向海量数据访问的面向文档数据库：主流代表为MongoDB，Amazon DynamoDB，Couchbase,Microsoft Azure Cosmos DB和CouchDB</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向搜索数据内容的搜索引擎：主流代表为Elasticsearch，Splunk，Solr，MarkLogic和Sphinx</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向可扩展性的分布式数据库：主流代表为Cassandra，HBase，Microsoft Azure Cosmos DB,Datastax Enterprise和Accumulo</td></tr></tbody></table><h2 id="非关系型数据库是否支持事物"><a href="#非关系型数据库是否支持事物" class="headerlink" title="非关系型数据库是否支持事物"></a>非关系型数据库是否支持事物</h2><blockquote><p>可扩展系统是可以支持高性能分布式原子事务的</p><blockquote><ul><li>在公平性、隔离性和吞吐量（FIT）三者之间进行取舍,一个支持分布式原子事务的可扩展数据库至少可以实现上述三个属性中的两个<ul><li>公平性: 任何事务的执行都不会因为其它事务被故意延迟</li><li>隔离性: 确保相互冲突的事务可以看到其它事务的写入操作</li></ul></li></ul></blockquote><p>FIT三者之间的取舍可以产生三种支持分布式原子事务的方案：</p><blockquote><ul><li>保证公平性和隔离性(FI),牺牲吞吐量</li><li>保证公平性和吞吐量(FT),牺牲隔离性</li><li>保证隔离性和吞吐量(IT),牺牲公平性</li></ul></blockquote><p>  放弃隔离性或者放弃公平性都可以构建出具备高分布式事务吞吐量的可扩展系统</p></blockquote><p>参考: </p><blockquote><ul><li><a href="https://blog.csdn.net/bifuguo/article/details/82379036" target="_blank" rel="noopener">数据库的历史发展 - 毕富国的博客 - CSDN博客</a></li><li><a href="https://www.jianshu.com/p/fd7b422d5f93" target="_blank" rel="noopener">简述关系型数据库和非关系型数据库</a></li><li><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">最近的数据库排名</a></li><li><a href="https://blog.csdn.net/kezhong_wxl/article/details/77000947" target="_blank" rel="noopener">NoSql对于事务的支持 - 克终的博客 - CSDN博客</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之熔断降级</title>
      <link href="/2019/04/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
      <url>/2019/04/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h5 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h5><ul><li>滑动窗口: 滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量</li></ul><h5 id="常用熔断框架比较"><a href="#常用熔断框架比较" class="headerlink" title="常用熔断框架比较"></a>常用熔断框架比较</h5><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">Sentinel</th><th style="text-align:center">Hystrix</th><th style="text-align:center">resilience4j</th></tr></thead><tbody><tr><td style="text-align:center">隔离策略</td><td style="text-align:center">信号量隔离（并发线程数限流）</td><td style="text-align:center">线程池隔离/信号量隔离</td><td style="text-align:center">信号量隔离</td></tr><tr><td style="text-align:center">熔断降级策略</td><td style="text-align:center">基于响应时间、异常比率、异常数</td><td style="text-align:center">基于异常比率</td><td style="text-align:center">基于异常比率、响应时间</td></tr><tr><td style="text-align:center">实时统计实现</td><td style="text-align:center">滑动窗口（LeapArray）</td><td style="text-align:center">滑动窗口（基于 RxJava）</td><td style="text-align:center">Ring Bit Buffer</td></tr><tr><td style="text-align:center">动态规则配置</td><td style="text-align:center">支持多种数据源</td><td style="text-align:center">支持多种数据源</td><td style="text-align:center">有限支持</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">多个扩展点</td><td style="text-align:center">插件的形式</td><td style="text-align:center">接口的形式</td></tr><tr><td style="text-align:center">基于注解的支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">限流</td><td style="text-align:center">基于 QPS，支持基于调用关系的限流</td><td style="text-align:center">有限的支持</td><td style="text-align:center">Rate Limiter</td></tr><tr><td style="text-align:center">流量整形</td><td style="text-align:center">支持预热模式、匀速器模式、预热排队模式</td><td style="text-align:center">不支持</td><td style="text-align:center">简单的 Rate Limiter 模式</td></tr><tr><td style="text-align:center">系统自适应保护</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">控制台</td><td style="text-align:center">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td style="text-align:center">简单的监控查看</td><td style="text-align:center">不提供控制台，可对接其它监控系统</td></tr></tbody></table><a id="more"></a><h5 id="线程和信号量的比较"><a href="#线程和信号量的比较" class="headerlink" title="线程和信号量的比较"></a>线程和信号量的比较</h5><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">信号量</th><th style="text-align:center">线程池</th></tr></thead><tbody><tr><td style="text-align:center">排队和超时</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">异步调用</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">额外开销</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">适用</td><td style="text-align:center">受信客户(可预估量级)</td><td style="text-align:center">不受信客户(第三方，数据库访问)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">高扇出(网关，依赖多)</td><td style="text-align:center">有限扇出</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">高频高速调用(缓存)</td><td style="text-align:center">–</td></tr></tbody></table><p>综上，比较倾向于使用Sentinel，因为Hystrix官方已不再开发，而resilience4j不太适合比较复杂的场景。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote><p><a href="http://www.vccoo.com/v/r67697" target="_blank" rel="noopener">限流熔断技术选型：从Hystrix到Sentinel</a><br><a href="https://my.oschina.net/yu120/blog/1790398" target="_blank" rel="noopener">微服务架构—服务降级</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 熔断 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之配置中心</title>
      <link href="/2019/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感谢董老师带领入门</p></blockquote><p>概述：微服务架构体系中配置中心是比较重要的组件之一，Spring Cloud官方自身提供了Spring Cloud Config分布式配置中心，由它来提供集中化的外部配置支持，它分为客户端和服务端两个部分</p><p>为什么需要配置中心</p><ul><li>配置实时生效</li><li>配置管理流程: 权限管控、灰度发布、版本管理、格式检验和安全配置等</li></ul><p>开源配置中心:</p><a id="more"></a><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">Spring Cloud Config</th><th style="text-align:center">Apollo</th><th style="text-align:center">Nacos</th></tr></thead><tbody><tr><td style="text-align:center">应用</td><td style="text-align:center">和对应Git中的文件名称关联</td><td style="text-align:center">在某个应用下面（不包含公共配置）</td><td style="text-align:center">使用 Group 作应用字段</td></tr><tr><td style="text-align:center">集群</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">灰度发布</td><td style="text-align:center">/bus/refresh端点的destination参数来指定</td><td style="text-align:center">支持</td><td style="text-align:center">不支持（0.9）</td></tr><tr><td style="text-align:center">权限管理</td><td style="text-align:center">依赖Git，比较完善</td><td style="text-align:center">通过项目的维度来对配置进行权限管理</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">版本管理&amp;回滚</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">配置格式校验</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">监听查询</td><td style="text-align:center">支持订阅</td><td style="text-align:center">灰度实例列表</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">多环境</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">多集群</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">实时推送</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">GitHub不需要，私有git需要，成本高较复杂</td><td style="text-align:center">本地缓存文件保证</td><td style="text-align:center">Mysql提供持久化</td></tr><tr><td style="text-align:center">运维成本</td><td style="text-align:center">高可用成本高</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">多语言支持</td><td style="text-align:center">Java和HTTP API，动态配置不足</td><td style="text-align:center">open API，接入成本较低</td><td style="text-align:center">主流语言，提供open API</td></tr><tr><td style="text-align:center">迁移支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持，存在从cloud config转换的兼容成本</td><td style="text-align:center">支持，可以无缝从Spring Cloud Conig切换</td></tr><tr><td style="text-align:center">性能对比</td><td style="text-align:center">从git拉取较慢</td><td style="text-align:center">较快，缓存+db</td><td style="text-align:center">较快，db</td></tr><tr><td style="text-align:center">版本</td><td style="text-align:center">2.0.0.M9</td><td style="text-align:center">1.2.0 release</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">单机读</td><td style="text-align:center">7QPS</td><td style="text-align:center">DB:7000QPS,cache:9000QPS</td><td style="text-align:center">15000QPS</td></tr></tbody></table><p>注：Nacos和Apollo使用同样的数据库（32C128G），部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD<br>多台机器，每台机器开启多个线程从配置中心读取不同的配置（3000个）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Java </tag>
            
            <tag> config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的那些坑</title>
      <link href="/2019/04/02/Mysql%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>/2019/04/02/Mysql%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h4 id="windows-免安装版"><a href="#windows-免安装版" class="headerlink" title="windows 免安装版"></a>windows 免安装版</h4><ul><li>参照下面这个安装流程<blockquote><p> <a href="https://blog.csdn.net/weixin_42831477/article/details/81413510" target="_blank" rel="noopener">windows下MySQL免安装版配置教程mysql-5.7.23-winx64.zip版本</a></p></blockquote></li><li>当发生报错如下<blockquote><p> 发生系统错误 193 。 *** 不是有效的 Win32程序。</p><ul><li>解决办法: Mysql安装目录中的bin文件夹中，删除一个mysqld大小为0kb的文件</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安装环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/31/hello/"/>
      <url>/2019/03/31/hello/</url>
      
        <content type="html"><![CDATA[<h3 id="博客搭建初始化"><a href="#博客搭建初始化" class="headerlink" title="博客搭建初始化"></a>博客搭建初始化</h3><h5 id="开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T-T）"><a href="#开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T-T）" class="headerlink" title="开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T_T）"></a>开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T_T）</h5><h6 id="今天竟然经历了做开发以来的第二次加班…-困"><a href="#今天竟然经历了做开发以来的第二次加班…-困" class="headerlink" title="今天竟然经历了做开发以来的第二次加班….困"></a>今天竟然经历了做开发以来的第二次加班….困</h6>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
