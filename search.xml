<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-结构型]]></title>
    <url>%2F2020%2F05%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面 什么是结构型的设计模式 类结构型：多个类组合成更大的类，只存在类继承和实现关系 对象结构型：类和对象组合的关联关系，根据合成复用原则，尽量使用关联关系代替继承 为什么要用组装现有类成为一个更大的结构，扩展出更强大的功能 模式类型 注：按重要程度排序 外观模式（Facade） 说明：统一方法对象访问内部接口 结构 Facade SubInterface 适用场景 常用的MVC分层就是一种外观模式，比如service层聚合了dao 统一接入的API网关 代理模式（Proxy） 说明：通过一个代理对象控制原对象 有一句名言可以让我们联想下 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决 结构 Proxy：代理类 Source：被代理类 SourceImpl： 静态代理：代理和被代理对象都需要实现目标接口，在运行前就有Class文件了 动态代理：代理类和被代理类有一种关联关系，动态生成字节码加载到JVM中，编译完没有Class文件 JDK动态代理：依靠反射机制获取接口实现 Cglib动态代理：对目标类生成子类以覆盖其子类方法 如下是一个静态代理的实现，但是扩展的时候需要一个类一个代理类，过多冗余所以又有了动态代理 1234567891011121314151617181920212223242526272829303132333435public class ProxyTest &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.invoke(); &#125;&#125;interface Source &#123; void invoke();&#125;class Sourceable implements Source &#123; @Override public void invoke() &#123; System.out.println("real invoke"); &#125;&#125;class Proxy implements Source &#123; @Override public void invoke() &#123; before(); Sourceable sourceable = new Sourceable(); sourceable.invoke(); after(); &#125; // 增强功能 private void after() &#123; System.out.println("after"); &#125; private void before() &#123; System.out.println("before"); &#125;&#125; jdk动态代理 1234567891011121314151617181920212223/** * jdk动态代理 */@AllArgsConstructorclass JdkProxy implements InvocationHandler &#123; private Object target; @Override public Object invoke(Object SelfProxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before"); Object result = method.invoke(target, args); System.out.println("after"); return result; &#125;&#125;// 调用入口， public static void jdkProxy()&#123; // 原理：通过反射获取接口方法对象，所以必须依赖接口 Source source = (Source)Proxy.newProxyInstance(Source.class.getClassLoader(), new Class[]&#123;Source.class&#125;, new JdkProxy(new Sourceable())); source.invoke(); &#125; cglib动态代理 12345678910111213141516171819class CglibProxy implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("before"); Object result = methodProxy.invokeSuper(o, objects); System.out.println("after"); return result; &#125;&#125;//调用入口public static void cglibProxy() &#123; // 原理：对目标类生成一个子类，覆盖其中方法，所以不能对final修饰的方法 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(ProxyTarget.class); enhancer.setCallback(new CglibProxy()); ProxyTarget proxyTarget = (ProxyTarget) enhancer.create(); proxyTarget.invoke(); &#125; 适用场景 Aop：日志记录/性能统计/安全控制/事物处理/异常处理 组合模式 （Composite） 说明：组合成为体现”部分-整体”的分层结构，并且例如树结构 结构 Component：抽象 Leaf：叶子结点 Composite：容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class CompositeTest &#123; public static void main(String[] args) &#123; AbstractComponent tree = new Tree("1", "parent"); AbstractComponent sub2 = new TreeNode("2", "sub2"); AbstractComponent sub3 = new TreeNode("3", "sub3"); sub2.add(sub3); tree.add(sub2); tree.print(); sub2.print(); sub3.print(); &#125;&#125;interface AbstractComponent &#123; void add(AbstractComponent abstractComponent); void print();&#125;@Dataclass Tree implements AbstractComponent &#123; private String layer; private String name; private List&lt;AbstractComponent&gt; children = new ArrayList(); public Tree(String layer, String name) &#123; this.name = name; this.layer = layer; &#125; @Override public void add(AbstractComponent abstractComponent) &#123; this.children.add(abstractComponent); &#125; @Override public void print() &#123; System.out.println(layer + "|----|" + name); &#125;&#125;@Dataclass TreeNode implements AbstractComponent &#123; private String layer; private String name; private List&lt;AbstractComponent&gt; children = new ArrayList(); public TreeNode(String layer, String name) &#123; this.name = name; this.layer = layer; &#125; @Override public void add(AbstractComponent abstractComponent) &#123; this.children.add(abstractComponent); &#125; @Override public void print() &#123; System.out.println(layer + "|----|" + name); &#125;&#125; 适用场景 比如部门组织列表 适配器模式（Adapter） 说明 : 将一个类的方法接口转换为另一类的接口 结构 Target：目标类 Adaptee：被适配者 Adapter：适配器 1234567891011121314151617181920212223242526272829303132333435363738public class AdapterTest &#123; public static void main(String[] args) &#123; Target classAdapter = new ClassAdapter(); classAdapter.invoke(); Target objApapter = new ObjectAdapter(new Adaptee()); objApapter.invoke(); &#125;&#125;interface Target &#123; void invoke();&#125;class Adaptee &#123; public void concreteInvoke() &#123; System.out.println("real invoke"); &#125;&#125;// 类适配器，通过继承class ClassAdapter extends Adaptee implements Target &#123; @Override public void invoke() &#123; super.concreteInvoke(); &#125;&#125;// 对象适配器，通过组合（最常用）@AllArgsConstructorclass ObjectAdapter implements Target &#123; private Adaptee adaptee; @Override public void invoke() &#123; adaptee.concreteInvoke(); &#125;&#125; 适用场景 JDK: InputSream -&gt; Reader , OutputStream -&gt; Writer，字节变字符 12345678910111213141516171819// 对象适配public class InputStreamReader extends Reader &#123; private final StreamDecoder sd; public InputStreamReader(InputStream in) &#123; super(in); ... &#125; ...&#125;public class OutputStreamWriter extends Writer &#123; private final StreamEncoder se; public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException&#123; super(out); ... &#125; ...&#125; 装饰器模式（Decorator） 说明：动态的给目标对像添加新功能 结构 Component：抽象组件 ConcreteComponet：具体组件 Decorator：装饰器 ConcreteDecorator：具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DecoratorTest &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponet(); Decorator decorator = new ConcreteDecorator(component); decorator.opertion(); &#125;&#125;interface Component &#123; void opertion();&#125;class ConcreteComponet implements Component &#123; @Override public void opertion() &#123; System.out.println("doing sth"); &#125;&#125;// 装饰器class Decorator implements Component &#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; @Override public void opertion() &#123; component.opertion(); &#125;&#125; // 通过对象组合class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; @Override public void opertion() &#123; System.out.println("增加了新功能"); super.opertion(); &#125;&#125; 适用场景 123456789101112131415161718public abstract class InputStream implements Closeable &#123; ...&#125;public class FilterInputStream extends InputStream &#123; protected volatile InputStream in; protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; ...&#125;// 装饰器实现，变化的部分public class DataInputStream extends FilterInputStream implements DataInput &#123; public DataInputStream(InputStream in) &#123; super(in); &#125; ...&#125; 桥接模式 （Bridge） 说明：使抽象和实现可以各自独立的变化 结构 Bridge Destination 1234567891011121314151617181920212223242526272829303132333435363738public class BridgeTest &#123; public static void main(String[] args) &#123; Destination destinationA = new DestinationA(); Destination destinationB = new DestinationB(); Bridge bridge = new Bridge(destinationB); bridge.bridgeDestination(); &#125;&#125;interface Destination &#123; void arrive();&#125;class DestinationA implements Destination &#123; @Override public void arrive() &#123; System.out.println("A"); &#125;&#125;class DestinationB implements Destination &#123; @Override public void arrive() &#123; System.out.println("B"); &#125;&#125;class Bridge &#123; private Destination destination; public Bridge(Destination destination)&#123; this.destination = destination; &#125; public void bridgeDestination() &#123; destination.arrive(); &#125;&#125; 享元模式（蝇量，FlyWeight） 说明：通过共享技术来有效的支持大量细粒度的对象 适用场景 数据库连接池 123456789101112131415161718class ConnectionPool &#123; ... @SneakyThrows private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 线程池 总结​ 对于结构型的设计模式，主要是在解决类或对象间的组合关系，利用结构来实现解耦的问题，多用组合少用继承，大部分还是使用对象的组合来关联他们 ​ 以上是一些学习总结及部分源码，最关键的还是在设计之前想好哪里会变哪里不大会变，这样会更好的使用设计模式，而且很多设计模式也很相似，可以参考说明对比他们的目的这样可以更好的理解 Todo 类图及排版优化如有不正确的地方欢迎大佬指正]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-创建型]]></title>
    <url>%2F2020%2F05%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面​ 发现对于落地这件事情还是要静下心一个一个目标完成，设计模式一直搁浅了好久也没个系统整理，作为网上标配开篇，最近还是补上这个作业吧 为什么用设计模式 设计模式是前人总结下来的经验，对于扩展性和可维护性有很大帮助 也是为了使设计变得简单，容易阅读 设计模式原则（SOLID） 单一职责原则（Single Responsibility Principle）：可以理解为最好一个类只负责一项职责 开闭原则（Open Close Priciple）：尽量对扩展开放，对修改关闭 里氏替换原则（Liskov Substitution Principle）：引用父类处可以用任意子类代替 接口隔离原则（Interface Segregation priciple）：建立单一接口，最好是一个类依赖一个接口，而不是多个类依赖一个接口 依赖倒置原则 (Dependency InVersion Principle) ：调用方和实现方都应该依赖抽象，彼此相互独立，实现类应该依赖抽象，而不能反过来 迪米特法则（Law of Demeter）：一个对象保持对其他对象最少的了解 合成复用原则（Composite/Aggregate Reuse Principle）：尽量使用组合/聚合，不要使用继承，继承基类会暴露实现破坏封装；基类改变，子类实现也需要改变；实现是静态的，不够灵活 如何使用设计模式 以上原则只是设计参考的一个约束，并不绝对，对于“最好的设计模式就是不用设计模式”，我们还没有达到这个境界，只有合适的场景用更合适的方法。 设计模式-创建型目的：实例化过程的解耦 ​ 我们原先想获取一个新对象 1Object o = new Object(); 之后在创建新对象的场景可以参考考虑一下使用以下的思路 单例模式说明：一个类只能有一个实例，提供全局唯一的访问点 匿名内部类 12345678910111213class SingletonInnerClass &#123; // 私有构造器保证不能new 创建新实例 private SingletonInnerClass() &#123; &#125; public static SingletonInnerClass getInstance() &#123; return SingletonInner.instance; &#125; private static class SingletonInner &#123; private static final SingletonInnerClass instance = new SingletonInnerClass(); &#125;&#125; 枚举类型 123enum SingletonEnum &#123; INSTACN；&#125; 双重检查锁 123456789101112131415161718class SingletonDCL &#123; private volatile static SingletonDCL instance; private SingletonDCL() &#123; &#125; public static SingletonDCL getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDCL.class) &#123; if (instance == null) &#123; instance = new SingletonDCL(); &#125; &#125; &#125; return instance; &#125;&#125; Spring单例注册表 123456789101112131415161718192021222324252627282930313233/** Cache of singleton objects: bean name to bean instance. */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** Cache of singleton factories: bean name to ObjectFactory. */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** Cache of early singleton objects: bean name to bean instance. 提前曝光的单例Cache*/private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);@Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // 一级缓存 获取单例的bean Object singletonObject = this.singletonObjects.get(beanName); // 判断bean是否在创建中（并未创建完） if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; // 二级缓存 获取提前曝光的单例 singletonObject = this.earlySingletonObjects.get(beanName); // 判断是否允许提前引用 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; // 三级缓存 获取单例bean ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; // 放入二级缓存 并删除三级缓存中的bean singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject; &#125; 上面也直接说了spring 对于循环依赖的解决方案 简单工厂说明：根据传入的变量决定输出什么样的实例 123456789101112131415161718192021222324252627282930interface Product &#123; void use();&#125;// 产品实现class ProductA implements Product &#123; @Override public void use() &#123; System.out.println("product A"); &#125;&#125;class ProductB implements Product &#123; @Override public void use() &#123; System.out.println("product B"); &#125;&#125;// 工厂class Factory &#123; public Product produce(String type) &#123; if ("A".equals(type)) &#123; return new ProductA(); &#125; else if ("B".equals(type)) &#123; return new ProductB(); &#125; else &#123; return null; &#125; &#125;&#125; 工厂方法说明：创建对象行为进行抽象，在子类里实现逻辑 适用场景： 如下是spring中的工厂方法接口 1234567891011public interface FactoryBean&lt;T&gt; &#123; @Nullable T getObject() throws Exception; @Nullable Class&lt;?&gt; getObjectType(); default boolean isSingleton() &#123; return true; &#125;&#125; jdk中Collection类 123456789101112public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; ... // 这是一个工厂方法 Iterator&lt;E&gt; iterator(); ...&#125;// 实现在子类中public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125;&#125; 抽象工厂说明：创建相关或依赖对象的家族，而无需明确指定具体类 - Collection类中抽象了多个工厂方法，本身又是一个抽象的创建类 建造者模式说明：封装一个对象复杂的构建过程 lombok @Builder 1234Builder builder = Builder .age(10) .name("builder") .build(); 原型模式说明：实例对象的复制获取新实例 123456789101112131415161718/** * 浅拷贝 * 对象内的引用也被复制时为深拷贝 */@Data@AllArgsConstructorclass Prototype implements Cloneable &#123; private String name; private Map&lt;String, String&gt; map; @Override public Prototype clone() throws CloneNotSupportedException &#123; Prototype prototype = (Prototype) super.clone(); prototype.map = map; prototype.name = name; return prototype; &#125;&#125; 总结以上是对创建型的设计模式的一些demo及一些源码的引用，目的是尽快的理解和快速的用起来，后续会补全UML图 其中最常用的是单例模式/工厂方法/抽象工厂/建造者模式，设计模式的主要目的也是为了代码的可维护性和可扩展性，把会变动的地方和不变的地方隔离开来 如有不正确的地方欢迎大佬指正]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Relational And Non-Relational Storage System]]></title>
    <url>%2F2019%2F05%2F05%2FRelational-And-Non-Relational-Storage-System%2F</url>
    <content type="text"><![CDATA[最近在研究ES的同时,有如下问题 数据存储发展历史 关系型和非关系型对比 非关系型数据库是否支持事物 下面对以上问题进行展开 数据存储发展历史TimeLine 数据管理是数据库的核心任务,分类、组织、编码、储存、检索和维护 人工管理阶段 没有对数据进行管理的软件系统 没有文件的概念 一组数据对应于一个程序，数据是面向应用的 数据不保存 文件系统阶段 数据需要长期保存在外存上供反复使用 程序之间有了一定的独立性 文件的形式已经多样化 数据的存取基本上以记录为单位 数据库系统阶段 采用复杂的结构化的数据模型 较高的数据独立性 最低的冗余度 数据控制功能 数据模型是数据库系统的核心 第一代: 层次和网状数据库管理系统 第二代: 关系数据库管理系统(RDBMS) 第三代: 面向对象的方法和技术，例如建立对象关系(OR)模型和建立对象关系数据库(ORDB) 数据库技术与多学科技术的有机结合: 例如分布式数据库、并行数据库、演绎数据库、知识库、多媒体库、移动数据库等 面向专门应用领域的数据库技术: 例如工程数据库、统计数据库、科学数据库、空间数据库、地理数据库、Web数据库 关系和非关系型对比 对比 Relational Non-Relational 定义 采用了关系模型来组织数据的数据库 非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统 优点 容易理解 仅需要根据id取出相应的value就可以完成查询 使用方便 适用于SNS(Social Networking Services),数据结构巨大变动 易于维护 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合 问题 硬盘I/O瓶颈 只适合存储一些较为简单的数据 海量数据效率低下 不适合持久存储海量数据 web的结构中难以横向扩展，需要停机和数据迁移 不适合较复杂查询的数据 格式化的数据结构，多表关联查询性能欠佳 事务 必须具备ACID特性 不支持 成本 相比较高且复杂 简单易部署，较低 查询速度 较慢 数据存储于缓存之中，而且不需要经过SQL层的解析，较快 存储数据的格式 只支持基础类型 key,value形式、文档形式、图片形式等等，基础类型以及对象或者是集合等各种格式 扩展性 扩展很艰难 数据之间没有耦合性，所以非常容易水平扩展 持久存储 海量数据的持久存储，还是需要关系型数据库 不适用于持久存储 数据一致性 强一致性 数据最终一致性，有可能有中间态的数据 主流系统 Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2,Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP 面向高性能并发读写的key-value数据库：主流代表为Redis， Amazon DynamoDB， Memcached,Microsoft Azure Cosmos DB和Hazelcast 面向海量数据访问的面向文档数据库：主流代表为MongoDB，Amazon DynamoDB，Couchbase,Microsoft Azure Cosmos DB和CouchDB 面向搜索数据内容的搜索引擎：主流代表为Elasticsearch，Splunk，Solr，MarkLogic和Sphinx 面向可扩展性的分布式数据库：主流代表为Cassandra，HBase，Microsoft Azure Cosmos DB,Datastax Enterprise和Accumulo 非关系型数据库是否支持事物 可扩展系统是可以支持高性能分布式原子事务的 在公平性、隔离性和吞吐量（FIT）三者之间进行取舍,一个支持分布式原子事务的可扩展数据库至少可以实现上述三个属性中的两个 公平性: 任何事务的执行都不会因为其它事务被故意延迟 隔离性: 确保相互冲突的事务可以看到其它事务的写入操作 FIT三者之间的取舍可以产生三种支持分布式原子事务的方案： 保证公平性和隔离性(FI),牺牲吞吐量 保证公平性和吞吐量(FT),牺牲隔离性 保证隔离性和吞吐量(IT),牺牲公平性 放弃隔离性或者放弃公平性都可以构建出具备高分布式事务吞吐量的可扩展系统 参考: 数据库的历史发展 - 毕富国的博客 - CSDN博客 简述关系型数据库和非关系型数据库 最近的数据库排名 NoSql对于事务的支持 - 克终的博客 - CSDN博客]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务之熔断降级]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Keys 滑动窗口: 滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量 常用熔断框架比较 对比 Sentinel Hystrix resilience4j 隔离策略 信号量隔离（并发线程数限流） 线程池隔离/信号量隔离 信号量隔离 熔断降级策略 基于响应时间、异常比率、异常数 基于异常比率 基于异常比率、响应时间 实时统计实现 滑动窗口（LeapArray） 滑动窗口（基于 RxJava） Ring Bit Buffer 动态规则配置 支持多种数据源 支持多种数据源 有限支持 扩展性 多个扩展点 插件的形式 接口的形式 基于注解的支持 支持 支持 支持 限流 基于 QPS，支持基于调用关系的限流 有限的支持 Rate Limiter 流量整形 支持预热模式、匀速器模式、预热排队模式 不支持 简单的 Rate Limiter 模式 系统自适应保护 支持 不支持 不支持 控制台 提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等 简单的监控查看 不提供控制台，可对接其它监控系统 线程和信号量的比较 对比 信号量 线程池 排队和超时 不支持 支持 异步调用 不支持 支持 额外开销 无 有 适用 受信客户(可预估量级) 不受信客户(第三方，数据库访问) 高扇出(网关，依赖多) 有限扇出 高频高速调用(缓存) – 综上，比较倾向于使用Sentinel，因为Hystrix官方已不再开发，而resilience4j不太适合比较复杂的场景。 参考 限流熔断技术选型：从Hystrix到Sentinel微服务架构—服务降级]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>熔断</tag>
        <tag>微服务</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务之配置中心]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[感谢董老师带领入门 概述：微服务架构体系中配置中心是比较重要的组件之一，Spring Cloud官方自身提供了Spring Cloud Config分布式配置中心，由它来提供集中化的外部配置支持，它分为客户端和服务端两个部分 为什么需要配置中心 配置实时生效 配置管理流程: 权限管控、灰度发布、版本管理、格式检验和安全配置等 开源配置中心: 对比 Spring Cloud Config Apollo Nacos 应用 和对应Git中的文件名称关联 在某个应用下面（不包含公共配置） 使用 Group 作应用字段 集群 支持 支持 支持 灰度发布 /bus/refresh端点的destination参数来指定 支持 不支持（0.9） 权限管理 依赖Git，比较完善 通过项目的维度来对配置进行权限管理 不支持 版本管理&amp;回滚 支持 支持 支持 配置格式校验 不支持 支持 支持 监听查询 支持订阅 灰度实例列表 支持 多环境 支持 支持 支持 多集群 支持 支持 支持 实时推送 不支持 支持 支持 高可用 GitHub不需要，私有git需要，成本高较复杂 本地缓存文件保证 Mysql提供持久化 运维成本 高可用成本高 高 低 多语言支持 Java和HTTP API，动态配置不足 open API，接入成本较低 主流语言，提供open API 迁移支持 支持 支持，存在从cloud config转换的兼容成本 支持，可以无缝从Spring Cloud Conig切换 性能对比 从git拉取较慢 较快，缓存+db 较快，db 版本 2.0.0.M9 1.2.0 release 0.5 单机读 7QPS DB:7000QPS,cache:9000QPS 15000QPS 注：Nacos和Apollo使用同样的数据库（32C128G），部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD多台机器，每台机器开启多个线程从配置中心读取不同的配置（3000个）]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Java</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的那些坑]]></title>
    <url>%2F2019%2F04%2F02%2FMysql%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[windows 免安装版 参照下面这个安装流程 windows下MySQL免安装版配置教程mysql-5.7.23-winx64.zip版本 当发生报错如下 发生系统错误 193 。 *** 不是有效的 Win32程序。 解决办法: Mysql安装目录中的bin文件夹中，删除一个mysqld大小为0kb的文件]]></content>
      <categories>
        <category>安装环境</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello%2F</url>
    <content type="text"><![CDATA[博客搭建初始化开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T_T）今天竟然经历了做开发以来的第二次加班….困]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
  </entry>
</search>
