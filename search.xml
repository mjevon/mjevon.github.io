<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-创建型</title>
      <link href="/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
      <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>​    发现对于落地这件事情还是要静下心一个一个目标完成，设计模式一直搁浅了好久也没个系统整理，作为网上标配开篇，最近还是补上这个作业吧</p><ol><li><p>为什么用设计模式</p><ul><li>设计模式是前人总结下来的经验，对于扩展性和可维护性有很大帮助</li><li>也是为了使设计变得简单，容易阅读</li></ul></li><li><p>设计模式原则（SOLID）</p><ul><li>单一职责原则（<strong>S</strong>ingle Responsibility Principle）：可以理解为最好一个类只负责一项职责</li><li>开闭原则（<strong>O</strong>pen Close Priciple）：尽量对扩展开放，对修改关闭</li><li>里氏替换原则（<strong>L</strong>iskov Substitution Principle）：引用父类处可以用任意子类代替</li><li>接口隔离原则（<strong>I</strong>nterface Segregation priciple）：建立单一接口，最好是一个类依赖一个接口，而不是多个类依赖一个接口</li><li>依赖倒置原则 (<strong>D</strong>ependency InVersion Principle) ：调用方和实现方都应该依赖抽象，彼此相互独立，实现类应该依赖抽象，而不能反过来</li><li>迪米特法则（<strong>L</strong>aw of Demeter）：一个对象保持对其他对象最少的了解</li></ul></li><li><p>如何使用设计模式</p><p>以上原则只是设计参考的一个约束，并不绝对，对于“最好的设计模式就是不用设计模式”，我们还没有达到这个境界，只有合适的场景用更合适的方法。</p></li></ol><a id="more"></a><h3 id="设计模式-创建型"><a href="#设计模式-创建型" class="headerlink" title="设计模式-创建型"></a>设计模式-创建型</h3><p>目的：实例化过程的解耦</p><p>​    我们原先想获取一个新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>   之后在创建新对象的场景可以参考考虑一下使用以下的思路</p><ol><li><h5 id="单例模式：一个类只能有一个实例，提供全局唯一的访问点"><a href="#单例模式：一个类只能有一个实例，提供全局唯一的访问点" class="headerlink" title="单例模式：一个类只能有一个实例，提供全局唯一的访问点"></a>单例模式：一个类只能有一个实例，提供全局唯一的访问点</h5><ul><li>匿名内部类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonInnerClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 私有构造器保证不能new 创建新实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInnerClass <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonInnerClass instance = <span class="keyword">new</span> SingletonInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTACN；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>双重检查锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDCL instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDCL <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDCL.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Spring单例注册表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name,Class requiredType,Object[] args)</span><span class="keyword">throws</span> BeansException</span>&#123;  </span><br><span class="line">          <span class="comment">//对传入的Bean name稍做处理，防止传入的Bean name名有非法字符(或则做转码)  </span></span><br><span class="line">          String beanName=transformedBeanName(name);  </span><br><span class="line">          Object bean=<span class="keyword">null</span>;  </span><br><span class="line">          <span class="comment">//手工检测单例注册表  </span></span><br><span class="line">          Object sharedInstance=<span class="keyword">null</span>;  </span><br><span class="line">          <span class="comment">//使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高  </span></span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonCache)&#123;  </span><br><span class="line">             sharedInstance=<span class="keyword">this</span>.singletonCache.get(beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">          <span class="keyword">if</span>(sharedInstance!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">             ...  </span><br><span class="line">             <span class="comment">//返回合适的缓存Bean实例  </span></span><br><span class="line">             bean=getObjectForSharedInstance(name,sharedInstance);  </span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            ...  </span><br><span class="line">            <span class="comment">//取得Bean的定义  </span></span><br><span class="line">            RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,<span class="keyword">false</span>);  </span><br><span class="line">             ...  </span><br><span class="line">            <span class="comment">//根据Bean定义判断，此判断依据通常来自于组件配置文件的单例属性开关  </span></span><br><span class="line">            <span class="comment">//如果是单例，做如下处理  </span></span><br><span class="line">            <span class="keyword">if</span>(mergedBeanDefinition.isSingleton())&#123;  </span><br><span class="line">               <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonCache)&#123;  </span><br><span class="line">                <span class="comment">//再次检测单例注册表  </span></span><br><span class="line">                 sharedInstance=<span class="keyword">this</span>.singletonCache.get(beanName);  </span><br><span class="line">                 <span class="keyword">if</span>(sharedInstance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">                    ...  </span><br><span class="line">                   <span class="keyword">try</span> &#123;  </span><br><span class="line">                      <span class="comment">//真正创建Bean实例  </span></span><br><span class="line">                      sharedInstance=createBean(beanName,mergedBeanDefinition,args);  </span><br><span class="line">                      <span class="comment">//向单例注册表注册Bean实例  </span></span><br><span class="line">                       addSingleton(beanName,sharedInstance);  </span><br><span class="line">                   &#125;<span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                      ...  </span><br><span class="line">                   &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">                      ...  </span><br><span class="line">                  &#125;  </span><br><span class="line">                 &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">              bean=getObjectForSharedInstance(name,sharedInstance);  </span><br><span class="line">            &#125;  </span><br><span class="line">           <span class="comment">//如果是非单例，即prototpye，每次都要新创建一个Bean实例  </span></span><br><span class="line">           <span class="comment">//&lt;bean id="date" class="java.util.Date" scope="prototype"/&gt;  </span></span><br><span class="line">           <span class="keyword">else</span>&#123;  </span><br><span class="line">              bean=createBean(beanName,mergedBeanDefinition,args);  </span><br><span class="line">           &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">       <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>ToDo</p><ol><li><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5></li><li><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5></li><li><h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5></li><li><h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h5></li><li><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Relational And Non-Relational Storage System</title>
      <link href="/2019/05/05/Relational-And-Non-Relational-Storage-System/"/>
      <url>/2019/05/05/Relational-And-Non-Relational-Storage-System/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在研究ES的同时,有如下问题</p><ul><li>数据存储发展历史</li><li>关系型和非关系型对比</li><li>非关系型数据库是否支持事物</li></ul></blockquote><p>下面对以上问题进行展开</p><a id="more"></a><h2 id="数据存储发展历史"><a href="#数据存储发展历史" class="headerlink" title="数据存储发展历史"></a>数据存储发展历史</h2><p>TimeLine</p><blockquote><p>数据管理是数据库的核心任务,分类、组织、编码、储存、检索和维护</p><blockquote><ul><li>人工管理阶段<ul><li>没有对数据进行管理的软件系统</li><li>没有文件的概念</li><li>一组数据对应于一个程序，数据是面向应用的</li><li>数据不保存</li></ul></li><li>文件系统阶段<ul><li>数据需要长期保存在外存上供反复使用</li><li>程序之间有了一定的独立性</li><li>文件的形式已经多样化</li><li>数据的存取基本上以记录为单位</li></ul></li><li>数据库系统阶段<ul><li>采用复杂的结构化的数据模型</li><li>较高的数据独立性</li><li>最低的冗余度</li><li>数据控制功能</li></ul></li></ul></blockquote><p>数据模型是数据库系统的核心</p><blockquote><ol><li>第一代: 层次和网状数据库管理系统</li><li>第二代: 关系数据库管理系统(RDBMS)</li><li>第三代: <ul><li>面向对象的方法和技术，例如建立对象关系(OR)模型和建立对象关系数据库(ORDB)</li><li>数据库技术与多学科技术的有机结合: 例如分布式数据库、并行数据库、演绎数据库、知识库、多媒体库、移动数据库等</li><li>面向专门应用领域的数据库技术: 例如工程数据库、统计数据库、科学数据库、空间数据库、地理数据库、Web数据库</li></ul></li></ol></blockquote></blockquote><h2 id="关系和非关系型对比"><a href="#关系和非关系型对比" class="headerlink" title="关系和非关系型对比"></a>关系和非关系型对比</h2><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:left">Relational</th><th style="text-align:left">Non-Relational</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:left">采用了关系模型来组织数据的数据库</td><td style="text-align:left">非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:left">容易理解</td><td style="text-align:left">仅需要根据id取出相应的value就可以完成查询</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">使用方便</td><td style="text-align:left">适用于SNS(Social Networking Services),数据结构巨大变动</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">易于维护</td><td style="text-align:left">非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:left">硬盘I/O瓶颈</td><td style="text-align:left">只适合存储一些较为简单的数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">海量数据效率低下</td><td style="text-align:left">不适合持久存储海量数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">web的结构中难以横向扩展，需要停机和数据迁移</td><td style="text-align:left">不适合较复杂查询的数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">格式化的数据结构，多表关联查询性能欠佳</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">事务</td><td style="text-align:left">必须具备ACID特性</td><td style="text-align:left">不支持</td></tr><tr><td style="text-align:center">成本</td><td style="text-align:left">相比较高且复杂</td><td style="text-align:left">简单易部署，较低</td></tr><tr><td style="text-align:center">查询速度</td><td style="text-align:left">较慢</td><td style="text-align:left">数据存储于缓存之中，而且不需要经过SQL层的解析，较快</td></tr><tr><td style="text-align:center">存储数据的格式</td><td style="text-align:left">只支持基础类型</td><td style="text-align:left">key,value形式、文档形式、图片形式等等，基础类型以及对象或者是集合等各种格式</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:left">扩展很艰难</td><td style="text-align:left">数据之间没有耦合性，所以非常容易水平扩展</td></tr><tr><td style="text-align:center">持久存储</td><td style="text-align:left">海量数据的持久存储，还是需要关系型数据库</td><td style="text-align:left">不适用于持久存储</td></tr><tr><td style="text-align:center">数据一致性</td><td style="text-align:left">强一致性</td><td style="text-align:left">数据最终一致性，有可能有中间态的数据</td></tr><tr><td style="text-align:center">主流系统</td><td style="text-align:left">Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2,Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP</td><td style="text-align:left">面向高性能并发读写的key-value数据库：主流代表为Redis， Amazon DynamoDB， Memcached,Microsoft Azure Cosmos DB和Hazelcast</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向海量数据访问的面向文档数据库：主流代表为MongoDB，Amazon DynamoDB，Couchbase,Microsoft Azure Cosmos DB和CouchDB</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向搜索数据内容的搜索引擎：主流代表为Elasticsearch，Splunk，Solr，MarkLogic和Sphinx</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td><td style="text-align:left">面向可扩展性的分布式数据库：主流代表为Cassandra，HBase，Microsoft Azure Cosmos DB,Datastax Enterprise和Accumulo</td></tr></tbody></table><h2 id="非关系型数据库是否支持事物"><a href="#非关系型数据库是否支持事物" class="headerlink" title="非关系型数据库是否支持事物"></a>非关系型数据库是否支持事物</h2><blockquote><p>可扩展系统是可以支持高性能分布式原子事务的</p><blockquote><ul><li>在公平性、隔离性和吞吐量（FIT）三者之间进行取舍,一个支持分布式原子事务的可扩展数据库至少可以实现上述三个属性中的两个<ul><li>公平性: 任何事务的执行都不会因为其它事务被故意延迟</li><li>隔离性: 确保相互冲突的事务可以看到其它事务的写入操作</li></ul></li></ul></blockquote><p>FIT三者之间的取舍可以产生三种支持分布式原子事务的方案：</p><blockquote><ul><li>保证公平性和隔离性(FI),牺牲吞吐量</li><li>保证公平性和吞吐量(FT),牺牲隔离性</li><li>保证隔离性和吞吐量(IT),牺牲公平性</li></ul></blockquote><p>  放弃隔离性或者放弃公平性都可以构建出具备高分布式事务吞吐量的可扩展系统</p></blockquote><p>参考: </p><blockquote><ul><li><a href="https://blog.csdn.net/bifuguo/article/details/82379036" target="_blank" rel="noopener">数据库的历史发展 - 毕富国的博客 - CSDN博客</a></li><li><a href="https://www.jianshu.com/p/fd7b422d5f93" target="_blank" rel="noopener">简述关系型数据库和非关系型数据库</a></li><li><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">最近的数据库排名</a></li><li><a href="https://blog.csdn.net/kezhong_wxl/article/details/77000947" target="_blank" rel="noopener">NoSql对于事务的支持 - 克终的博客 - CSDN博客</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之熔断降级</title>
      <link href="/2019/04/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
      <url>/2019/04/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h5 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h5><ul><li>滑动窗口: 滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量</li></ul><h5 id="常用熔断框架比较"><a href="#常用熔断框架比较" class="headerlink" title="常用熔断框架比较"></a>常用熔断框架比较</h5><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">Sentinel</th><th style="text-align:center">Hystrix</th><th style="text-align:center">resilience4j</th></tr></thead><tbody><tr><td style="text-align:center">隔离策略</td><td style="text-align:center">信号量隔离（并发线程数限流）</td><td style="text-align:center">线程池隔离/信号量隔离</td><td style="text-align:center">信号量隔离</td></tr><tr><td style="text-align:center">熔断降级策略</td><td style="text-align:center">基于响应时间、异常比率、异常数</td><td style="text-align:center">基于异常比率</td><td style="text-align:center">基于异常比率、响应时间</td></tr><tr><td style="text-align:center">实时统计实现</td><td style="text-align:center">滑动窗口（LeapArray）</td><td style="text-align:center">滑动窗口（基于 RxJava）</td><td style="text-align:center">Ring Bit Buffer</td></tr><tr><td style="text-align:center">动态规则配置</td><td style="text-align:center">支持多种数据源</td><td style="text-align:center">支持多种数据源</td><td style="text-align:center">有限支持</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">多个扩展点</td><td style="text-align:center">插件的形式</td><td style="text-align:center">接口的形式</td></tr><tr><td style="text-align:center">基于注解的支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">限流</td><td style="text-align:center">基于 QPS，支持基于调用关系的限流</td><td style="text-align:center">有限的支持</td><td style="text-align:center">Rate Limiter</td></tr><tr><td style="text-align:center">流量整形</td><td style="text-align:center">支持预热模式、匀速器模式、预热排队模式</td><td style="text-align:center">不支持</td><td style="text-align:center">简单的 Rate Limiter 模式</td></tr><tr><td style="text-align:center">系统自适应保护</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">控制台</td><td style="text-align:center">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td style="text-align:center">简单的监控查看</td><td style="text-align:center">不提供控制台，可对接其它监控系统</td></tr></tbody></table><a id="more"></a><h5 id="线程和信号量的比较"><a href="#线程和信号量的比较" class="headerlink" title="线程和信号量的比较"></a>线程和信号量的比较</h5><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">信号量</th><th style="text-align:center">线程池</th></tr></thead><tbody><tr><td style="text-align:center">排队和超时</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">异步调用</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">额外开销</td><td style="text-align:center">无</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">适用</td><td style="text-align:center">受信客户(可预估量级)</td><td style="text-align:center">不受信客户(第三方，数据库访问)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">高扇出(网关，依赖多)</td><td style="text-align:center">有限扇出</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">高频高速调用(缓存)</td><td style="text-align:center">–</td></tr></tbody></table><p>综上，比较倾向于使用Sentinel，因为Hystrix官方已不再开发，而resilience4j不太适合比较复杂的场景。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><blockquote><p><a href="http://www.vccoo.com/v/r67697" target="_blank" rel="noopener">限流熔断技术选型：从Hystrix到Sentinel</a><br><a href="https://my.oschina.net/yu120/blog/1790398" target="_blank" rel="noopener">微服务架构—服务降级</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 熔断 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之配置中心</title>
      <link href="/2019/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/04/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>感谢董老师带领入门</p></blockquote><p>概述：微服务架构体系中配置中心是比较重要的组件之一，Spring Cloud官方自身提供了Spring Cloud Config分布式配置中心，由它来提供集中化的外部配置支持，它分为客户端和服务端两个部分</p><p>为什么需要配置中心</p><ul><li>配置实时生效</li><li>配置管理流程: 权限管控、灰度发布、版本管理、格式检验和安全配置等</li></ul><p>开源配置中心:</p><a id="more"></a><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">Spring Cloud Config</th><th style="text-align:center">Apollo</th><th style="text-align:center">Nacos</th></tr></thead><tbody><tr><td style="text-align:center">应用</td><td style="text-align:center">和对应Git中的文件名称关联</td><td style="text-align:center">在某个应用下面（不包含公共配置）</td><td style="text-align:center">使用 Group 作应用字段</td></tr><tr><td style="text-align:center">集群</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">灰度发布</td><td style="text-align:center">/bus/refresh端点的destination参数来指定</td><td style="text-align:center">支持</td><td style="text-align:center">不支持（0.9）</td></tr><tr><td style="text-align:center">权限管理</td><td style="text-align:center">依赖Git，比较完善</td><td style="text-align:center">通过项目的维度来对配置进行权限管理</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">版本管理&amp;回滚</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">配置格式校验</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">监听查询</td><td style="text-align:center">支持订阅</td><td style="text-align:center">灰度实例列表</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">多环境</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">多集群</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">实时推送</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">GitHub不需要，私有git需要，成本高较复杂</td><td style="text-align:center">本地缓存文件保证</td><td style="text-align:center">Mysql提供持久化</td></tr><tr><td style="text-align:center">运维成本</td><td style="text-align:center">高可用成本高</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">多语言支持</td><td style="text-align:center">Java和HTTP API，动态配置不足</td><td style="text-align:center">open API，接入成本较低</td><td style="text-align:center">主流语言，提供open API</td></tr><tr><td style="text-align:center">迁移支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持，存在从cloud config转换的兼容成本</td><td style="text-align:center">支持，可以无缝从Spring Cloud Conig切换</td></tr><tr><td style="text-align:center">性能对比</td><td style="text-align:center">从git拉取较慢</td><td style="text-align:center">较快，缓存+db</td><td style="text-align:center">较快，db</td></tr><tr><td style="text-align:center">版本</td><td style="text-align:center">2.0.0.M9</td><td style="text-align:center">1.2.0 release</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">单机读</td><td style="text-align:center">7QPS</td><td style="text-align:center">DB:7000QPS,cache:9000QPS</td><td style="text-align:center">15000QPS</td></tr></tbody></table><p>注：Nacos和Apollo使用同样的数据库（32C128G），部署Server服务的机器使用的8C16G配置的容器，磁盘是100G SSD<br>多台机器，每台机器开启多个线程从配置中心读取不同的配置（3000个）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Java </tag>
            
            <tag> config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的那些坑</title>
      <link href="/2019/04/02/Mysql%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>/2019/04/02/Mysql%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h4 id="windows-免安装版"><a href="#windows-免安装版" class="headerlink" title="windows 免安装版"></a>windows 免安装版</h4><ul><li>参照下面这个安装流程<blockquote><p> <a href="https://blog.csdn.net/weixin_42831477/article/details/81413510" target="_blank" rel="noopener">windows下MySQL免安装版配置教程mysql-5.7.23-winx64.zip版本</a></p></blockquote></li><li>当发生报错如下<blockquote><p> 发生系统错误 193 。 *** 不是有效的 Win32程序。</p><ul><li>解决办法: Mysql安装目录中的bin文件夹中，删除一个mysqld大小为0kb的文件</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安装环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/31/hello/"/>
      <url>/2019/03/31/hello/</url>
      
        <content type="html"><![CDATA[<h3 id="博客搭建初始化"><a href="#博客搭建初始化" class="headerlink" title="博客搭建初始化"></a>博客搭建初始化</h3><h5 id="开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T-T）"><a href="#开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T-T）" class="headerlink" title="开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T_T）"></a>开始写博客！（之前搭过得，又忘记了怎么玩，只能重搞T_T）</h5><h6 id="今天竟然经历了做开发以来的第二次加班…-困"><a href="#今天竟然经历了做开发以来的第二次加班…-困" class="headerlink" title="今天竟然经历了做开发以来的第二次加班….困"></a>今天竟然经历了做开发以来的第二次加班….困</h6>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
